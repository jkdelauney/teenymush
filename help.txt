& help
   ===[ Basic Commands ]================================================

      go <direction>                look               look <thing>
      pose <text>                   QUIT               say <text>
      whisper <player>=<text>       WHO                
   
   Quick Help for beginners          |  General MUSH Topics
      help basics                    |     help topics
                                     |
   To get a list of commands         |  To get a list of functions()
      help commands                  |     help functions
                                     |
   Help on a command or function     |  Help on public com system
      help <command>                 |     com help

   =====================================================================
& basics
You've connected to a MUSH, so now what do you do? Well, MUSHes
are broken up into many different rooms. There's many different ways
to interact in a room or people within a room. Lets start with a few
important commands to interact with the things around you.

look
   This command will tell you about the room your currently in.
   It should list a description of the room, contents of the room,
   and a list of exits on how to get out of the room.

go <direction>
   Traveling through an exit to another room.

say <message>
   Say something to the people in your current room.

"<message>
   A shortened version of the say command. This alias will save you
   a few clicks on the keyboard.

pose <message>
   Perform an action like smiling by typing in: pose smiles

:<message>
   a shortened version of the pose command.

whisper <person> = <message>
   Want to say something to a particular person? Whisper it to them
   and no one else will hear it. This only works with people in the
   same room.

WHO
   Not everyone on-line will be in the same room as you, the WHO
   command lists everyone connected to the MUSH.

page <person> = <message>
   Send a message to a person in any room 
& topics
    basics
& "
command:

   "<message>

Says <message> to everyone in your current location.

Example:              |   Output
===========================================================
                      |
"Hello.               |   You say, "Hello"

Also see: say
& &
command:

   &<attribute> <object> = <text>

This command is used to store information on an object. The text
may be either generic information or Mushcode. <text> can be
later retrieved with the get function or maybe examined.

Example:              |   Output
===========================================================
                      |
&foo me = bar         |   Set.
                      |
examine me/foo        |   FOO: bar

Also see: examine, get(), @set, &&

& &&
command: 

   &&<attribute> <object> = <text>

This is the multiline version of the @set and & command. Any
commands issued after this command will be added to the end
of attribute's value. Issuing a single blank line will end 
the command. A period on a blank line can be used in place 
of a blank line.
   
Example:              |   Output
===========================================================
                      |
&&foo me = bar        |
bar                   |
.                     |
boo                   |
                      |   Set.
examine me/foo        |   FOO: bar
                      |   biz
                      |
                      |   boo

Also see: examine, get(), @set, &
& :
command: 

   :<message>
 
Performes an action to everyone in your current room. If
there is a space between the ":" and the message, there
will be no space in between your name and your message.
This is also a shortcut for the pose command.


Example:              |   Output
===========================================================
                      |
:smiles               |   Guest smiles
: 's eyes light up.   |   Guest's eyes light up.

Also see: pose
& ;
command:

   ;<message>
 
This command is like the ":" command except that there
is no space inserted between your name and the action.


Example:              |   Output
===========================================================
                      |
;'s eyes light up.    |   Guest's eyes light up.
; 's eyes light up.   |   Guest 's eyes light up.

Also see: pose, :
& @@
command: 

   @@ <text>
 
This command is useful for putting comments into a Mushcode.
The command actually does nothing but makes your code more
readable.

Example:              |   Output
===========================================================
                      |
&&foo me=$dg  *:      |
   @@ Dog Controller  |
   @force #0=%0       |
                      | Set.
dg smiles.            | Dog smiles.
& @boot
command: 

   @boot <player>
   @boot/port <port#>

Disconnects a player from the game. If the player is connected
multiple times, then all connections are disconnected. Optionally,
a port may be specified to be more presice about which connection
is disconnected. Port numbers are listed on the WHO for wizards.

Example:              |   Output
===========================================================
                      |
@boot adrick          | Adrick has been @booted.
                      | Adrick has disconnected.
                      |
@boot/port 1          | Adrick has been @booted.
                      | Adrick has disconnected.

Also see: WHO
& @close
I don't think this command does anything, scheduled for removal or fixing.
& @cls
command: 

   @cls

This command sends a -- line and clear screen command to the console. 
This is useful for debuging output as it happens. Results are not
visible from inside the MUSH.
& @code
command: 

   @code

Lists stats on how big the version of TeenyMUSH is that is
currently running broken down by file. Size is listed in bytes
and lines.
& @commit
command: 

   @commit

Forces a commit to the mysql database. TeenyMUSH typically commits
as needed but occasionally there is a need to force a commit.
This command is wizard only.
& @crash
command: 

   @crash

This forces TeenyMUSH to perform an operation which will crash the
MUSH. A stack trace will be produced on the console and the player
invoking the command. The MUSH will recover from the crash and 
continue on, hopefully. Safe for anyone to use.
& @create
command: 

   @create <name>

Creates a object with the specified name. Objects can be molded
with descriptions, attributes, and flags to be whatever you want. 
Each object gets its own id number. Keep track of this number
as it can help with coding it to do things or find it after it
has been lost.

Example:              |   Output
===========================================================
@create puppet        | Object created as: Puppet(#119o)

See Also: @destroy, @set, @describe
& commands
run: @list commands
& functions
run: @list functions
& @describe
command: 

   @describe <name> = <description>

Sets the description for an object. People will see this description
if they look at the object. An empty description will remove the
description from the object.


Example:               |   Output
============================================================
@describe puppet=Shiny | Set.

look puppet            | Shiny


See Also: @set
& @destroy
command: 

   @destroy <object>

Instantly deletes the object from the MUSH. Opposite of @create.
& @dig
command:

   @dig <name> 
   @dig <name> = <exitlist1> , <exitlist2>

Creates a new room with the specified name. Optionally providing
an exit list can create exits going in and out of the newly created
room in one command. Exit list 1 provides exits going to the room
while exit list 2 provides an exit coming back to your current
location. Multiple exit names can be provided by use of a semi-
colon between exit names.

Example:                |  Output
===============================================================
@dig Hotel              |  Creates a room named Hotel
@dig Hotel=In,Out       |  Creates a room with in and out exits
@dig Hotel=Inn;in,Out;o |  Creates the room with in and out
                           exits with aliases of in and o.

See also: @open, @link
& @doing
command:

   @doing <message>

Sets your @doing message which is visible on the DOING/WHO command.
Use this to tell people what your up to.

See also: DOING, WHO
& @dolist
command:

   @dolist <list> = <action>

Takes a list and runs the code once for every item in the list.
As the code is run, the special symbol ## is replaced with the
current item from the list.

Example:                |  Output
===============================================================
@dolist a b c = say ##  |  You say, "a"
                        |  You say, "b"
                        |  You say, "c"
& @find
command:

   @find
   @find <name>

Lists all the objects that you own or just those who's name contains
<name>.
& @password
command:

   @password <old_password> = <new_password>

   This command change your password. Passwords must contain 8 characters
   or more, contain at least one upper case character, and contain at least
   one numeric character.
& @mail
command:

   @mail                                  : Shows an shortened list of email
   @mail short                            : Shows a count of emails
   @mail <number>                         : Reads one email message
   @mail <person> = <message>             : Sends an email message
   @mail/delete <number>                  : Deletes an email message

   This command is used for displaying or sending email to/from other people.

   ex:
      @mail adrick = testing
      @mail 1
      @mail/delete 1
& @name
command:

   @name <object> = <new_name>

   This changes the name of an <object> to <new_name>. Names may contain
   ansi color codes and use of a seperate @moniker is not required.
& @switch
command:

   @switch[/switch} <string>=<test>,<cmd>,<test>,<cmd>,...,<default_cmd>

   If <string> matches <test>, the command following the <test> is run.
   Only the first match is concerned. If no matches are made, then the
   <default_cmd> is run if it exists.

   <test> may include * wild cards. Text matched by the wildcard maybe
   retrieved using %m0 - %m9. The <test> may also include > and < for
   greater and less then comparisons.

   For readability, the <default_cm> may have an optional preceeding
   <test> of DEFAULT.

   Availible switches:

      /regexp        :   Use regular expression matching instead of
                         simple wildcard matching. All "\" characters
                         will need to be escaped out due to the nature
                         of how MUSH deals with the "\" character.

Example:                                               |  Output
===========================================================================
@switch abc=*b*,say %m0,*e*,say def,DEFAULT,say !match |  You say, "a"
@switch def=*b*,say %m0,*e*,say def,DEFAULT,say !match |  You say, "def"
@switch ghi=*b*,say %m0,*d*,say def,DEFAULT,say !match |  You say, "!match"
@switch ghi=*b*,say %m0,*d*,say def,say !match         |  You say, "!match"
@switch abcde=^ab(.*)e$,say %m0                        |  You say, "cd"

& input()
function:

    input()     : Returns a line of input from a connected socket opened from
                  the @telnet command. If a line of data is not unavailible
                  yet, the function will return "#-1 No data found". If the
                  connection has closed, the function will return 
                  "#-1 Connection Closed".

    input(last) : Returns the last connection's data for the whole MUSH. If
                  the connection is still pending, only partial data will be
                  returned. This is implimented for debug purposes only.

See: @telnet, telnet_open()
&url
function:

   url(http://address/path)
   url(https://address/path)

      This function is a way to pull web pages via MushCode. It must be used
      within a loop command like @while. The function will return 1 as long
      as the connection is still open or there is data to return. The responce
      from the website may be retrieved from the %{data} variable.

   Error Responces contained in %{data}:

       #-1 CONNECTION FAILED    :   url() was unable to connect to the remote
                                    site.

       #-1 PAGE LOAD FAILURE    :   url connected but the server responded
                                    with a 400 or higher return code.
       #-1 DATA PENDING         :   No data was availible at this time

   Example:

      @while (url(https://www.wowbagger.com/process.php)) {
         @switch %{data}=
            #-1 CONNECTION FAILED,
               say I'm out of insults \[connection failed\],
            #-1 PAGE LOAD FAILURE,
               say =I'm out of insults \[page load failure\],
            #-1 DATA PENDING,
               @@ ignore,
            *customBig>*<*,
               say %m1
      }

& @perl
command:

   @perl <command>

   This invokes <command> via perl's eval() function. <Command> must be
   a valid perl command. Only GOD may run this command.
& entities()
function:

    entities(encode,<txt>)  :  Encodes <txt> with HTML entities.
    entities(decode,<txt>)  :  Decodes <txt> with HTML entities.

Example:
    say entities(encode,<'>)       :  You say, "abc&lt;&#39;&gt;def"
    say entities(encode,&lt;&gt;)  :  You say, "<>"
& match()
function:
    match(<string>,<pattern>)
    match(<string>,<pattern>,<delimiter>)

    Compares each word or segment of the string against the provided pattern
    to see if it matches. If a match occures, the function returns the word
    or segment position that was matched. If no match occures, the function
    will return 0. 

    Patterns may use * to match multiple characters or ? to match a single
    character.

Example:
     say match(abc def,def)               :  You say, "2"
     say match(abc def,*e?)               :  You say, "2"
     say match(funky|abc def|foo,*e*,|)   :  You say, "2"
& @trigger
command:

   @trig <obj>/<attr> 
   @trig <obj>/<attr> = <parm1>,<parm2>, .. <parm9>?

   Runs the commands in the attribute on object. The Parameters are passed
   in via %0 .. %9. You must control the object or the attribute must be
   a $command.
& setunion()
function:
    setunion(<string1>,<string2>,[<delim>,<seperator>,<sort type>])

    Returns <string1> and <string2> after removing duplicate words. The
    results are sorted alphanumerically or by <sort type>. Optionally, a
    delimter and output seperator may be used.

    <Sort type> may be:
        N :  Numberic
        F :  Floating point
        D :  Debref
        A :  Alphanumeric

Example:
     say setunion(a b c d e, d c f)        :  You say, "a b c d e f"
     say setunion(a|b|c|d|e,d|c|f,|,\,)    :  You say, "a,b,c,d,e,f"
     say setunion(#453 #3,#5 #3 #463,,,d)  :  You say, "#3 #5 #453 #463"
& setdiff()
function:
    setdiff(<string1>,<string2>,[<delim>,<seperator>,<sort type>])

    Returns those words in <string1> that are not in <string2>. The
    results are sorted alphanumerically or by <sort type>. Optionally, a
    delimter and output seperator may be used.

    <Sort type> may be:
        N :  Numberic
        F :  Floating point
        D :  Debref
        A :  Alphanumeric

Example:
     say setunion(a b c d e, d c f)        :  You say, "a b c d e f"
     say setunion(a|b|c|d|e,d|c|f,|,\,)    :  You say, "a,b,c,d,e,f"
     say setunion(#453 #3,#5 #3 #463,,,d)  :  You say, "#3 #5 #453 #463"
& lit()
function:
    lit(<string1>,<string2>..., <stringN>)

    Returns the strings as is without any modification. Good for 
    showing code to others?

Example:
     > say lit(say [run(say [run(say [run(say test %b %s %p)])])])

     You say, "say [run(say [run(say [run(say test %b %s %p)])])]"

& @set
command:

   @set object = [!] flag
   @set object/attribute = [!] attribute_flag


   Sets a flag on either an object or attribute.

See: @list flags
& v()
function:
    v(attribute)

    Returns the attribute on the calling object.

Example:
     &foo me = bar
     > say v(foo)

     You say, "bar"
& @sleep
command:

   @sleep <seconds>

   Causes the current running MUSH code to pause <seconds> before continuing
   on. 

Example:
   &foo me = say [time()];@sleep 5;say [time()]
   @trig me/foo

   You say, "Thu Jan 31 12:39:04 2019"
   You say, "Thu Jan 31 12:39:10 2019"

See: @wait
& @wait
command:

   @wait <seconds> = <command>

   Runs <command> after waiting <seconds>. Any commands after the @wait
   command will not wait to be run. 

Example:
   &&foo me = $foo:
      say BEFORE: [time()];
      @wait 5=say MIDDLE: [time()];
      say AFTER: [time()]

   @trig me/foo
   You say, "BEFORE: Thu Jan 31 12:39:04 2019"
   You say, "AFTER: Thu Jan 31 12:39:04 2019"
   You say, "MIDDLE: Thu Jan 31 12:39:10 2019"

See: @sleep
& stats()
function:
    stats(<player>)

    Returns the number of objects in the database broken down by total
    objects, rooms, exits, things, players, and garbage owned by 
    <player>. All stats are returned if <player> is replaced with "all"
    or no arguments are passed in.

Example:
     > say stats(me)
     You say, "30 4 7 18 1 0"
     > say stats(all)
     You say, "304 63 153 36 52 1008"
& mod()
function:
     mod(<number1>,<number1>)

     returns the modulus of two numbers. This is the remainder from dividing
     <number1> by <number2>.
& escape()
function:

     escape(<text>)

     Puts a "\" character before any special characters like: %{}[];, 

Example:
     > say escape({}[]();,)
     You say, "\{\}\[\]\(\)\;"
& trim()
TRIM()
  Function: trim(<string> [,<trim style> [,<trim character(s)>]])
 
  This function will trim trailing and/or lead characters on the string
  that you specify.  <trim character> specifies the character to trim (default
  is space), and <trim style> tells the kind of trimming to perform (default
  is trim both sides of the string).  You may specify more than one character
  for trimming.
 
  The following values for <trim style> are recognized:
      'b' :   Trim both ends of the string (default)
      'l' :   Trim the left end of the string.
      'r' :   Trim the right end of the string.
  Note: anything else specified for <trim style> will trim both sides.
 
  Example:
    > say trim(;;;Wacka;;;,,;)
    You say "Wacka"
    > say trim(%b%b%b Polly Parrot %b%b%b%b,r)
    You say "    Polly Parrot"
    > say trim(---Trim Rules!---,l,-)
& @wipe
command :
     @wipe <object>
     @wipe <object>/<pattern>

     Erases an object or just those attributes that match <pattern>
& fullname()
function:

     fullname(<object>)

     Returns the entire name of exits. Name() only returns the first name.

Example:
     @open out;leave;exit;o = #42
     > say fullname(out)
     You say, "out;leave;exit;o"
     > say name(out)
     You say, "out"
& strmatch()
function:

     strmatch(<text>,<pattern>)

     Returns 1 or 0 depending upon if <pattern> matches the whole string
     in <text> or not. Similar to match()

Example:
     > say strmatch(the quick brown fox,*fox*)
     You say, "1"
     > say strmatch(the quick brown fox,fox*)
     You say, "0"
& filter()
function:

     filter(<attribute>,<list>)

     Takes a list of words and passes each word in <list> to the
     <attribute> as %0. If it evaluates to 1 then the word is returned,
     if it evaluates to 0, the word is excluded.

Example:
     > &tolong object = [gt(length(%0),10)]
     > say filter(tolong,thisisatest of the world)
     You say, "of the world"
& null()
function:

     null(<text>)

     Evaluates <text> but doesn't return the results. Nothing is
     returned. This can be used for supressing the output of functions.

Example:
     > say null(repeat(x,75))
     You say, ""
& args()
function:

     args(<delim>)

     This function returns all the arguements %0 .. %999 that were 
     passed in. This could be used inside of u() to iterate through
     a variable number of arguments.

Example:

     > &foo me = [args(|)]
     > say u(foo,1,2,3,4,5,6,7,8,9,10,11,12)

     You say, "1|2|3|4|5|6|7|8|9|10|11|12"
& shift()
function:

     shift()

     This function will return and remove %0 and move all arguments 
     %1 .. %999 down one position so that %1 is now %0, %2 is now %1,
     etc.

Example:
     > &foo me = Shifted Value = [shift()], \%0 = %0, \%1 = %1
     > say u(foo,1,2,3)

     You say, "Shifted Value = 0, %1 = 1, %2 = 2"
& unshift()
function:

     unshift(<value>)

     This function will add will <value> to %0 causing every other
     position to be moved down one. %0 will become %1, %1 will become
     %2, etc.

Example:

     > &foo me = [unshift(foo)]\%0 = %0, \%1 = %1, \%2 = %2
     > say u(foo,1,2)

     You say, "%0 = foo, %1 = 0, %2 = 1"
& pop()
function:

     pop()

     This function will return the last %0 - %999 value and remove
     it from the list.

Example:

     > &foo me = Popped Value=[pop()], \%0 = %0, \%1 = %1, \%2 = %2
     > say u(foo,1,2,3,4)

     You say, "Popped Value=4,%0 = 1, %1 = 2, %2 = 3"
& push()
function:

     push(<value>)

     This function will add <value> after the last %0 - %99 value.

Example:

     > &foo me = [push(foo)]\%0 = %0, \%1 = %1, \%2 = %2
     > say u(foo,1,2)

     You say, "%0 = 1, %1 = 2, %2 = foo"
& asc()
function:

     asc(<delim>)

     Returns the ASCII numberical value of the first character of
     <delim>

Example:

     > say asc(F)

     You say, "70"
& ord()
function:

     ord(<number>)

     Returns the character associated with the decimal <number> according
     to the standard ASCII table. Google ASCII Table.


Example:

     > say ord(35)

     You say, "#"

Also see: chr()
& asc()
function:

     asc(<number>)

     Returns the character associated with the decimal <number> according
     to the standard ASCII table. Google ASCII Table. This is an alias for
     the ord() function.


Example:

     > say asc(35)

     You say, "#"

Also see: ord(), chr()

    
& @perl
command:

   @perl <code>

   Runs the <code> inside of perl. Not recommended but useful for fixing
   something that can't be normally fixed.

Example:

   @perl printf("%s\n",print_var($prog));

& say
command:

   say <text>
   say/noeval <text>

   Causes your character to say something which can be heard by everyone
   in the current room. A shortened version of this command is to use
   a double quote.

   Using the /noeval switch causes the command not to evaluate <text>
   so that it is said as is.

Example:

   > say Hello.
   You say, "Hello."

   > "Hello
   You say, "Hello."

   > say/noeval %0 %1 %2
   You say, "%0 %1 %2"
& @reload
command:

   @reload

   If any changes to the perl script have been made, then this command will
   load those changes into the currently running TeenyMUSH server. You must
   be set GOD to use this command.

& pose
command:

   pose <text>

   This command is used to express an action. Your name is prefixed before
   <text> and is announced to everyone in the current room. A shortcut for
   this command is ":".

Example:

   > pose smiles.

   Guest smiles.

   > :smiles.

   Guest smiles.

Also see: emote
& emote
command:

   pose <text>

   This command is similar to the pose command but without a space between
   your name and <text>. Your name is prefixed before <text> without a space
   and is announced to everyone in the current room. A shortcut for this
   command is ";".

Example:

   > emote 's eyes light up.

   Guest's eyes light up.

   > ;'s eyes light up.

   Guest's eyes light up.

Also see: pose
& who
command:

   WHO
   WHO <name>

   This command lists all people who are connected to the TeenyMUSH server
   at this time. This command also lists time connected, amount of time
   idle, and their @doing. If a name, or partial name, is provided, then
   only those players who match <name> will be listed.
& lcon()
function:

    lcon(<object>)

    Returns a list of object dbrefs that are in <object>. You may do an
    lcon() on those objects you own, or you are in. Dark objects are always
    excluded.
& pid()
function:

    pid()

    Returns the pid of the currently running program.

Example:
 
    > say pid()

    You say, "31776"
& lpid()
function:

    lpid()

    Returns all pids of any currently running program that you control.

Example:
 
    > say lpid()

    You say, "31776 31781"

& whisper
command:

   whisper <object> = <message>
   whisper <message>

   Want to say something to a particular person? Whisper it to them
   and no one else will hear it. This only works with people in the
   same room.

   If no object is specified, the whisper will go to the last person
   that you whispered to if they are still around.

ex:
   > whisper guest = Hello
   You whisper, "Hello" to Guest.

   > whisper Hello
   You whisper, "Hello" to Guest.
& @quota

   @quota
   @quota <player>
   @quota <player> = <amount>


   Sets the amount of quota that a player may use if a <amount> is
   specified. Otherwise the command will just list the quota for
   yourself or a specified player.

ex:
   > @quota
   Adrick Quota:        50  Used:         0

   > @quota Kligore
   Kligore Quota:        50  Used:         0

   > @quota Kligore = 10
   Kligore Quota:        10  Used:         0
& `
command:

   '<person> <message>

   Sends a message to everyone in the current room directed towards a
   particular person.

ex:
   > 'kilgore Hello
   Adrick [to Kilgore]: Hello
& to
run: help `
& html_strip()
function:

    html_strip(<text>)


    Returns what <text> would be rendered like in a purely text
    format removing all html tags.

Example:
 
    > say html_strip(<a href=foo>bar</a>)

    You say, "bar"

& substitutions
SUBSTITUTIONS
  Topic: SUBSTITUTIONS
 
  All messages may contain %-substitutions, which evaluate to gender-specific
  pronouns if the player's gender is set or to other useful information.
  Information returned is based on the player that caused the message to be
  displayed, not the object that stored the message or which is running the
  action list.  The substitutions available are:
 
    %s, %S    = he, she, it, they.              (subjective)
    %o, %O    = him, her, it, them.             (objective)
    %p, %P    = his, her, its, their.           (possessive)
    %a, %A    = his, hers, its, theirs.         (absolute possessive)
    %n, %N    = the player's name.
    %k, %K    = the player's colorized/accented name.
    %r        = carriage return.
    %t        = tab character.
    %b        = space character.
    %%        = literal '%' character.
    %0-%9     = Value of positional parameter/stack location 0 through 9.
    %m0 - %m9 = Matches wild card 0 - 9 from a conditional statment in
                @switch.
    %va-%vz   = Contents of attribute va through vz.
    %q0-%q9   = Value of temporary (setq) register 0 through 9.
    %qa-%qz   = Value of temporary (setq) register a through z.
    %#        = Database number of the object that caused the message to be
                displayed or the action list to be run (Enactor).
    %!        = Database number of the object holding the message or running
                the action list (Executor).
& ansi
function:

  ansi(<codes>,<string>)

  This allows you to change the color of the a string of text.

ansi codes:

  f - flash                       i - inverse
  h - hilite                      n - normal
  u - underline

  x - black foreground            X - black background
  r - red foreground              R - red background
  g - green foreground            G - green background
  y - yellow foreground           Y - yellow background
  b - blue foreground             B - blue background
  m - magenta foreground          M - magenta background
  c - cyan foreground             C - cyan background
  w - white foreground            W - white background
& fdiv()

  FUNCTION: fdiv(<number1>,<number2>)

  Returns the floating point quotient from dividing <number1> by <number2>.
  <number> may be a floating point number, and a floating point result is
  returned.

  Examples:
    > say fdiv(15,3)
    You say, "5"
    > say fdiv(16,3)
    You say, "5.333333"
    > say fdiv(17,3)
    You say, "5.666667"
    > say fdiv(18,3)
    You say, "6"
    > say fdiv(-17,3)
    You say, "-5.666667"
    > say fdiv(10,3.5)
    You say, "2.857143"

& round()
  FUNCTION: round(<number>,<places>)

  Rounds <number> to <places> positions right of the decimal point. <places>
  may be negative in which case the rounding occurs in the ones, tens,
  hundreds, etc. place.

  Examples:
    > say round(5.123,1)
    You say, "5.1"
    > say round(9.8765,3)
    You say, "9.877"
    > say round(5.5,0)
    You say, "6"
    > say round(-5.5,0)
    You say, "-6"
    > say round(520,-3)
    You say, "1000"

& if()

  FUNCTION:     if(<expression>,<true string>[,<false string>])
            ifelse(<expression>,<true string>,<false string>)

  This function returns <true string> if BOOLEAN <expression> is TRUE,
  <false string> otherwise. Much more efficient than an equivalent switch().
  It can also return different messages based on whether <expression> is
  nothing or contains text.  if() does the same thing, but the third,
  <false string> argument is optional.

  Example:
    > think ifelse(v(test),Test exists!,Test doesn't exist.)
    Test doesn't exist.

& ifelse()
run: help if()
& lrand()
LRAND()

  FUNCTION: lrand(<lower>,<upper>,<count>,[,<output delim>])

  Returns a list with <count> elements separated by <output delim> (or
  a space if not specified) of random numbers between <lower> and
  <upper>.

  For instance, 'lrand(3, 6, 5)' would generate five random numbers
  in the range 3 - 6 (i.e., 3, 4, 5, or 6), such as '4 6 3 5 6'.
& pickrand()
PICKRAND()

  FUNCTION: pickrand(<word1> <word2> <...<wordN>[,<delimiter>])

  This function picks a random element from a list.  It's faster than
  first(shuffle(foo)) or extract(foo,rand(words(foo)),1).  <delimiter> is an
  optional one-character output delimiter.

  Example:
    > say pickrand(foo bar baz)
    You say, "bar"
& ilev()
ILEV()

  FUNCTION: ilev()

  Returns the nesting level of iter() and parse() functions. Outside
  of any iterator, ilev() returns -1. The first level is indicated by 0, the
  second by 1, etc.
& itext()
ITEXT()

  FUNCTION: itext(<n>)
            inum(<n>)
            ilev()

  These functions, when called within an iter() or parse(), return the
  equivalent of ## (itext) or #@ (inum), with reference to the nth more
  outermost iter(), where n=0 refers to the current iter(), n=1 to an iter()
  in which the current iter() is nested, etc.

  Unlike the ## and #@ substitutions which are substituted in the evaluation
  string before it is evaluated, itext(), inum(), and ilev() substitute their
  values as part of evaluation. In this way, the use of these functions is
  safer than the ## and #@ substitutions and is therefore preferred.

  > say [iter(red blue green,iter(fish shoe, #@:##))]
  You say, "1:red 1:red 2:blue 2:blue 3:green 3:green"

  > say [iter(red blue green,iter(fish shoe, [inum(1)]:[itext(1)]))]
  You say, "1:red 1:red 2:blue 2:blue 3:green 3:green"

  > say [iter(red blue green,iter(fish shoe, [inum(0)]:[itext(0)]))]
  You say, "1:fish 2:shoe 1:fish 2:shoe 1:fish 2:shoe"

  > say [iter(red blue green,iter(fish shoe, [itext(1)]:[itext(0)]))]
  You say, "red:fish red:shoe blue:fish blue:shoe green:fish green:shoe"
& inum()
run: help itext()
& foreach()
 Function: foreach([<object>/]<attribute>,<string>[,<begin>, <end>])
   
  Each character in <string> has the user-defined function of the first
  argument performed on it; the character is passed to the function as
  %0. The results are concatenated. If <begin> and <end> are specified,
  only the characters between <begin> and <end> are parsed, other characters
  are concatenated as they are. This allows a rudimentary form of tokens and
  speeds up the evaluation greatly if tokenizing is your purpose.
   
  Examples:
    > &add_one me=[add(%0,1)]
    Set.
    > say [foreach(add_one, 54321)]
    You say, "65432"
    > &add_one me=[add(%0,1)]
    Set.
    > say [foreach(add_one, This adds #0# to numbers in this string.,#,#)]
    You say, "This adds 1 to numbers in this string."
& listinter()
LISTINTER()
  Function: listinter(<list1>, <list2>[, <delim> [, <sep>] [,<type>]]])
  
  This function returns the intersection of two sets, keeping the order of the
  first set.  Any element in <list1> that is in <list2> will be
  displayed.  The following types exist:
  
      0 - remove duplicates from lists (default)
      1 - show list with duplicates
  
  Example:
    > say listinter(foo baz gleep bar foo bar, bar moof gleep)
    You say, "gleep bar"
    > say listinter(foo baz gleep bar foo bar, bar moof gleep,,-)
    You say, "gleep-bar"
    > say listinter(foo baz gleep bar foo bar, bar moof gleep,,-,1)
    You say, "gleep-bar-bar"
& lnum()
  Function: lnum(<number>[,<number>,<seperator>])
 
  Returns a list of numbers from 0 to <number>-1.
  If a second number is specified it tells to use
  the range of numbers between the two values.
  The order you put it in specifies if it increments
  or decrements the value.
 
  Example:
    > say lnum(5) 
    You say "0 1 2 3 4"
    > say lnum(5,10)
    You say "5 6 7 8 9 10"
    > say lnum(7,3)
    You say "7 6 5 4 3"
    > say lnum(1,5,@)
    You say "1@2@3@4@5"
& ldelete()
LDELETE()

  FUNCTION: ldelete(<list>, <positions>[, <input delim> [, <output delim>]])

  This function removes elements(s) from <list> at the given <positions>.
  Negative <positions> are relative to the end of the list.  Elements of
  <list> are delimited by <input delim>.  Elements of <positions> are always
  delimited by a space.

  Elements of the returned list are separated by <output delim> which
  defaults to <input delim> which defaults to a space.

  Examples:
    > say ldelete(This is not a test, 3)
    You say, "This is a test"
    > say ldelete(Yet@Another@Mundane@List, 3, @)
    You say, "Yet@Another@List"
    > say ldelete(lemon|orange|pear|apple,2 3,|)
    You say, "lemon|apple"
    > say ldelete(foo bar baz boing,3,,%b~%b)
    You say, "foo ~ bar ~ boing"
& edit()
EDIT()
  Function: edit(<string>, <from>, <to> [[,<type>] [,<strict>]])
 
  This function edits <string>, replacing all occurrences of the substring
  <from> with the string <to>.  If <from> is '$', then <to> is appended to
  <string>, while if <from> is '^', then it is prepended.
  
  <type> has the following values that are allowed:
    1 - enable single edit (where it edits the first match no sequent matches)
  
  <strict> has the following values that are allowed:
    1 - strict mode will keep ansi alignment to original strings values.
    2 - raw mode will allow you to edit ansi markup in a string.
  
  Note: option 2 (raw mode) was the original method ansi worked.
   
  Examples:
    > say edit(This is a test,is,x)   
    You say "Thx x a test"
    > say edit(Atlantic,^,Trans)
    You say "TransAtlantic"
& citer()
CITER()
  Function: citer(<list>, <eval>[, <delim>])
  
  <list> is a list of characters that you wish to iterate.  The list can
  be any regular character (including spaces).  <eval> is a string that is
  to be evaluated once for each character in <list>.  It returns a SPACE
  (or optional delimited) separated list of these evaluations.  The effect
  is similar to that of iter(), except it takes it as a character by 
  character basis instead of a word by word basis.  The special substitution
  of '##' is used for the current item of the list.  #@ is used for the
  positional match of that item in that list.  This is similar to 
  the explode function found on other mushes or in PHP.
  
  This function does not handle itext/inum/%i.  
   
  Examples:
    > say citer(boo!,##)
    You say "b o o !"
    > say citer(boo!,##-#@)
    You say "b-1 o-2 o-3 !-4"
    > say citer(testing,strlen(##))
    You say "1 1 1 1 1 1 1"
    > say citer(bob,## WHEE ##,@)
    You say "b WHEE b@o WHEE o@b WHEE b"
& @capture
Command: @capture <attribute> = <command>

  This command will run a command and capture the output. When
  the command finishes running, the specified attribute will
  be trigged with %1 containing the output from the command.
  This command will @capture output from most mushcode and 
  most internal commands.

  Example:
      &responce me = say # %0
      @capture responce = @weather 56001

      You say, "# Uptime: 63 days, 6 hours, 49 minutes"
& center()
CENTER()

  FUNCTION: center(<string>, <width>[, <fill>])

  This function centers <string> within a <width>-sized field.

  The background of this field is specified by a repeating pattern of <fill>
  characters. The origin of this repeating pattern is at the first position
  of the field. Another way of saying this is that the repeating pattern
  starts in first position and repeats to the right. The last <fill> pattern
  may be truncated.

  By default, <fill> is a single, normal-colored space. The color of
  <string> and <fill> is maintained.

  If the visual width of <string> is longer than <width> characters, it is
  truncated to fit.

  Example:
    > say center(a,5,-)
    You say, "--a--"
& set()
SET()

  FUNCTION: set(<object>, <string>)

  Works the same as @set, <object> and <string> are equivalent to what comes
  before and after the '=' sign.  Returns nothing.

  The following demonstrate how to use set() for setting or clearing a flag,
  attribute flag, or attribute on an object. As with @set, flags are cleared
  by using an exclamation mark(!) preceding the flag name for both general and
  attribute flags.  For attributes, an empty value after the colon (:) will
  clear the attribute value from the <object>.

    set(<object>, <flag>)
    set(<object>/<attribute>, <attribute flag>)
    set(<object>, <attribute>:<value>)

  Examples:

  > think [set(me,foo:Twenty Pink Pigs)]
  < think [set(me,foo:)]
  > think [set(me,VERBOSE)]
  > think [set(me/foo,!VISUAL)]

  Related Topics: @set
& @IDESC

  COMMAND:   @idesc <object> = <message>
  ATTRIBUTE: Idesc

  Sets the internal description for <object>.  The internal description of an
  object will be shown to any player entering it.  If not set, the regular
  description in the Desc attribute is shown instead.

  Function references and %-substitutions are allowed in inside descriptions,
  and are evaluated when someone fails to get or look at the object.  In
  function references, 'me' refers to the object being looked at, while
  %-substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the player doing the looking.

  This attribute is only meaningful for players and things, and will never be
  automatically triggered on other object types.

  Example: @idesc car = You are sitting in the driver's seat of a Volkswagen
                        Beetle.
& @SHUTDOWN

  COMMAND: @shutdown <text>

  Disconnects all connected players, saves the database to disk, and shuts
  down the game.  The game is unavailable until it is restarted.

& @WALL

  COMMAND: @wall[/<switches>] <message>

  With no switches, shouts <message> to every connected player or to every
  connected wizard, prefixed by either 'Announcement:' (if for everyone) or
  'Broadcast:' (if for wizards).  The following switches can be used to get the
  described effects:

     /emit      - Format the message as an emit (ie send just <message>).
     /pose      - Format the message as a pose (ie <yourname> <message>).
     /wizard    - Only send the message to connected wizards.
     /admin     - Send the message to connected wizards and royalty.
     /no_prefix - Don't prepend 'Announcement:' or 'Broadcast:' to the message.

  If neither /emit or /pose are used, you can format the message one of several
  ways by specifying ':', ';', or '"' as the first character of the message.
  ':' and ';' format the message as if /pose were specified, except that ';'
  does not insert a space between your name and the message.  '"' formats the
  message in normal @wall format (this is the default).
  The message is also written to the log file.

& attr_created()
attr_create()

  FUNCTION: attr_created(<object>, <attribute>)
            attr_created(<object> / <attribute>)

  Returns a number which corresponds to the time of the creation of the
  attribute. See convsecs() to convert this into a human readable time.

  Examples:

  > say [attr_created(me,testing)]
  > say [attr_created(me/testing)]

  You say, "1570464266"

  > think [convsecs(attr_created(me/testing))]

   You say, "Mon Oct  7 11:04:26 2019"

  Related Topics: @set, convsecs(), attr_modified()

& attr_modified()
attr_modified()

  FUNCTION: attr_modified(<object>, <attribute>)
            attr_modified(<object> / <attribute>)

  Returns a number which corresponds to the time of the modification of the
  attribute. See convsecs() to convert this into a human readable time.

  Examples:

  > say [attr_modified(me,testing)]
  > say [attr_modified(me/testing)]

  You say, "1570464266"

  > think [convsecs(attr_modified(me/testing))]

   You say, "Mon Oct  7 11:04:26 2019"

  Related Topics: @set, convsecs(), attr_created()

& EXAMINE

  Command: examine[/<switches>] <object>[/<wild-attrib>]
  
  Available switches are on: help examine4
  
  Displays all available information about <object>.  <object> may be an
  object, 'me' or 'here'. You must control the object to examine it, or it
  must be set VISUAL.  If you do not own the object, you will just see the
  name of the object's owner, and optionally any public attributes and 
  attributes owned by you set on the object.
 
  If an attribute is owned by a player other than the owner of the object,
  the number of the attribute owner is shown in parentheses immediately
  following the attribute name.  Flag letters may appear in parentheses also,
  to indicate the status of the attribute.

  If you specify a wildcard-ed attribute name, then only those attributes
  that match are shown.  So, 'exam me/v?' will show all your attributes that
  start with v and are two characters long.

  The following switches are available:

     /raw     - Shows the attributes as is without any formating to make
                MushCode more readable.

     /command - List attributes with a $-command, ^-listen, or !-listen.
                Good for finding commands on an object. 

     /detail  - List the creation and modification times on an attribute

  Related Topics: look
& @search
@SEARCH

  COMMAND: @search [<player>] [<class>=<restriction>

  Displays information about objects that meet the search criteria.
  Because this command is computationally expensive, it costs 100 coins.
  <player> restricts the search to the named player, while <class>
  and <restriction> control the objects listed.

  Except when getting lists of players ('@search type=player' or
  '@search flags=P'), you may only search for objects that you own.

  Examples:
    @search flags=PWc              <-- search for connected wizards.
    @search type=room              <-- list all rooms owned by me.
    @search eval=gt(money(##),10)  <-- search for things worth more than 10.
    @search type=room,100,300      <-- Rooms between #100 and #300, inclusive
                                       #5000 to the end of the database.
  Related Topics: @find
& train
TRAIN
  Command: train
  The train command is used to output to the player what exactly you have 
  typed.  The output is not parsed and is taken verbatum and displayed as
  is. 
  
  Example:
    > train @emit To do addition, type:  say add(1,1) = 2
    YourName types -=> @emit To do addition, type: say add(1,1) = 2
    To do addition, type: say add(1,1) = 2                         
  
  See Also: @emit, pose, @pemit, think

& s()
  Function: s(string)

  This function works like eval() in that it evaluates the string doing full
  pronoun substitution and function evaluation and then returns that string.
  As usually, %n is the name, %s the subjective pronoun, %o the objective,
  %p the possessive, and %a the absolute possessive.  It is important to
  note that the pronoun is that of the triggering object.

  So, if the ve of an object were: "[s(This is %n)], and I were to
  type @trigger <object>/ve, it would return "This is <myname>", but
  if vf were @trigger me/ve, then triggering the vf makes the ve
  return "This is <object>"

  As stated, this will also evaluate functions as well. 

  Example:
    > @sex me=male
    Set.
    > s(this [add(1,1)] %p)
    You say "this 2 his"
    > eval(this [add(1,1)] %p)
    You say "this 2 his"
    > subeval(this [add(1,1)] %p)
    You say "this [add(1,1)] his"

  See Also: SUBSTITUTIONS, eval(), u(), v()


& list()
  FUNCTION: list(<list>, <eval>[, <delim>])

  This function is exactly like iter() but serves a specialized purpose:
  MUX has a buffer limit, and for things like lists of players, iter() can
  quickly become inadequate, since the output is cut off before the listing
  is finished. The normal way to handle this is to use a @dolist/@pemit
  combination, but that takes many queue cycles. list() takes <list>,
  <eval>, and an optional delimiter, and evaluates them exactly like
  iter(). The difference is the output: iter() produces a space-separated
  list, while list() outputs each list item on a new row of the screen.

  NOTE: This is a side effect function. It does not return anything,
  instead, it prints its output directly to the screen of the player causing
  the function to be evaluated. Since it does this, it is not hampered by
  the buffer limit.

  Related Topics: iter(), @dolist, parse().

& lconf()
  FUNCTION: lconf()

  This function will list the configuration options that TeenyMUSH uses.
  This is dynamically generated, so could be missing some entries if
  a particular peice of code has not been exercised.

& lvariable()
  FUNCTION: lvariable(<pattern>)

  Returns a list of all variables defined in the currently running
  Mushcode or just those that match the pattern.

  ex: think # [run(@var foobar=biz)][run(@var funky=mama)][lvariable()]
  # FOOBAR FUNKY

  ex: think # [run(@var foobar=biz)][run(@var funky=mama)][lvariable(fo*)]
  # FOOBAR

& @restore

  COMMAND: @restore <object>
           @restore <object>/<attribute>

  This command will restore a full object or an attribute from a
  previous backup in the dumps folder.

  When restoring an object, the newest version of the object found in the
  dump folder will be used.

  When restoring an attribute, all unique versions of the attribute will
  be restored. To help limit the number of copies, spacing will not be
  considered when determining if the attribute's contents are unique.
  The attribute will be saved to the original object as the attribute
  named followed by a "_" and the modification time in seconds since
  the EPOC.
& strcat
  Function: strcat(<string>[,<string2>,...,<stringx>])

  Returns the strings concatinated with no spaces between them.

  Example:
    > say strcat(this,is,a,test)
    You say "thisisatest"
    > say strcat(one,2,three,4)
    You say "one2three4"
& @ping

  COMMAND: @ping <command>

  This command helps find whats command will run the specified command.
  If an object would run the command via a $command then the object name,
  attribute name, and where the object is located is displayed.

& readonly()
  FUNCTION: readonly()

  Places the command in readonly mode. No modifications to the DB may be
  made afterwards. Useful for sandboxing?

  > think [readonly()][run(&foo me=bar)]
  Set.
  > ex me/foo
  No matching attributes.
  > think [run(&foo me=bar)]
  Set.
& encrypt()
  Function: encrypt(<string>,<seed>)

  Returns an encrypted string based on the given seed.  The longer the seed,
  the better the password.

  Example:
    > say encrypt(this is a test,a)
    You say "VJKUaKUaCaVGUV"

  See Also: decrypt(), base64()
& decrypt
  Function: decrypt(<string>,<seed>)

  Returns a decrypted string based on the given seed and encrypted string.
  You have to match the seed (case sensitive) to be able to decrypt the
  string properly.

  Example:
    > say encrypt(VJKUaKUaCaVGUV,a)
    You say "this is a test"

  See Also: encrypt(), encode64(), base64()
& default()
  Function:  default(<obj>/<attr>,<default case>)

  This function returns the value of <obj>/<attr>, as if retrieved via
  the get() function, if the attribute exists and is readable by you.
  Otherwise, it evaluates the default case, and returns that.
  Note that the default case is only evaluated if the attribute does
  not exist or cannot be read.

  This is useful for code that needs to return the value of an attribute,
  or an error message or default case, if that attribute does not exist.

  Examples:
    > &TEST me=apple orange banana
    > say default(me/Test, No fruits!)
    You say "apple orange banana"
    > &TEST ME
    > say default(me/Test, No fruits!)
    You say "No fruits!"

  See Also: get(), u()

& inc()
  FUNCTION: inc(<number>)

  Returns <number> plus 1. Faster and more efficient than
  add(<number>,1). Decimal places are truncated.

  Related Topics: add(), dec(), sub().
& dec()
  FUNCTION: dec(<number>)

  Returns <number> minus 1. Faster and more efficient than
  sub(<number>,1). Decimal places will be truncated.

  Related Topics: sub(), add(), inc().
& startime()
  FUNCTION: starttime()

  Returns a string which is the time the MUX last rebooted.  The time
  is in the same format as the TIME() function returns.

  Example:
    > say starttime()
    You say, "Sat Dec  7 00:09:13 1991

  Related Topics: convtime().
& orflags()
  FUNCTION: orflags(<object>,<list of flags>)

  This function returns 1 if <object> has at least one of the flags in
  a specified list, and 0 if it does not. The list is specified with a
  single letter standing for each flag, like the output of the FLAGS()
  function. A '!' preceding a flag letter means "not flag".

  Thus, ORFLAGS(me,WZ) would return 1 if I were set WIZARD or ROYALTY.
  ORFLAGS(me,D!c) would return 1 if I were DARK or not CONNECTED.

  If a letter does not correspond to any flag, <object> doesn't have
  it, so it is simply ignored. There can be an arbitrary number of
  flags. Do not put spaces between flag letters.

  Related Topics: flags()
& strtrunc()
  FUNCTION: strtrunc(<string>,<number>)

  This function returns <string> truncated if it is longer than <number>. If
  <number> is greater than the length of <string>, it just returns <string>.
  Much more efficient than the equivalent mid().

  Related Topics: mid(), ljust().
& findable()
  FUNCTION: findable(<object>,<victim>)

  Returns 1 if <object> can locate <victim>, or 0 otherwise. This checks
  wizard status of <object>, UNFINDABLE status of <victim>, and other
  related factors. If <object> would not be able to see <victim> were
  they in the same location a 0 will be returned.
& power()
  FUNCTION: power(<number>, <power>)

  Returns the result of raising <number> to the <power>'th power.
  <number> may not be negative.  <number> and <power> may be floating point
  numbers, and a floating point result is returned.

  Examples:
    > say power(2,3)
    You say, "8"
    > say power(9, 0.5)
    You say, "3"
    > say power(5, 0)
    You say, "1"
    > say power(0, 0)
    You say, "1"
    > say power(2,-3)
    You say, "0.125"
& conn()
  FUNCTION: conn(<player|port>)

  Returns the number of seconds that <player|port> has been connected.  If
  <player|port> is not connected then -1 is returned.

  If <player|port> is numeric, it's taken as a port number (as shown in
  SESSION).  Otherwise, it's treated as a player name.  If the named player is
  connected more than once, the longest connect time is returned.

  Example:
    > WHO
    Player Name          On For Idle  Doing
    Wizard                00:04   1m
    Mortal                00:11   0s
    Evinar                00:12   6m  Idle. :)
    3 Players logged in.
    > say conn(wiz)
    You say, "251"
    > say conn(e)
    You say, "770"
    > say conn(frobozz)
    You say, "-1"

  Related Topics: WHO, idle(), lwho().
& bor()
  FUNCTION: bor(<number>[, <number>[, ...]])

  Arguments must be an integer and are treated as a bit-field.  It performs a
  bitwise logical OR which has the effect of forcing certain bits on in the
  result.

     > think bor(922,785)
     923

  In the above example, 922 in base 10 is equivalent to 39A in base 16 or
  0011 1001 1010 in base 2. Likewise, 785 in base 10 is the same as 311 in
  base 16 and or 0011 0001 0001 in base 2.

         0011 1001 1010 (922)
  (BOR)  0011 0001 0001 (785)
         --------------
         0011 1001 1011 (923)

  The result may be expressed as 39B in base 16 or 923 in base 10.
& convtime()
  Function: convtime(<time string>)

  This functions converts a time string to the number of seconds since
  Jan 1, 1970. A time string is of the format: Ddd MMM DD HH:MM:SS YYYY
  where Ddd is the day of the week, MMM is the month, DD is the day
  of the month, HH is the hour in 24-hour time, MM is the minutes,
  SS is the seconds, and YYYY is the year.
  If you supply an incorrectly formatted string, it will return -1.

  Example:
    > say time()
    You say "Wed Jun 24 10:22:54 1992"
    > say convtime(Wed Jun 24 10:22:54 1992)
    You say "709395774"

  See Also: convsecs(), secs(), time()
& convsecs()
  Function: convsecs(<seconds>)

  This function converts seconds to a time string, based on how many
  seconds the number is after Jan 1, 1970.

  Example:
    > say secs()
    You say "709395750"
    > say convsecs(709395750)
    You say "Wed Jun 24 10:22:54 1992"

  See Also: convtime(), secs(), time()
& @last
  COMMAND: @last <player>
           @last/full <player>

  This command displays a short 'connection history' for <player>, showing
  recent successful and failed connection attempts, as well as the total
  number of successful and failed connections. You can only display
  information about yourself unless your a Wizard or God. Only God may
  use the /full switch which will show the full hostname.
& @ban
  COMMAND: @ban <pattern>
           @ban/unban <pattern>

  This command displays sites that have been banned from connecting to the
  MUSH via httpd. It optionally can unban sites if needed.
& xget()

  FUNCTION: xget(<object>,<attribute>)

  This function works exactly like get(), but uses the object and attribute
  separated into two arguments.

  Related Topics: get(), eval(), get_eval().

& mush_address()

  FUNCTION: mush_address()

  This function returns the public address for the mush server.

& @missing

  COMMAND: @missing <command>

  This command runs <command> and logs which commands and functions do
  not exist. If a function() or @command exists in the code being run
  but is not run, it will not be logged as missing. This is usefull for
  determining compatability between TeenyMUSH and other MUSH servers by
  helping identify what is missing.

  > &foo me = $+fun:@funky;think [missing_function()]
  > @missing +fun
  Huh? (Type "HELP" for help.)
  #-1 Undefined function
  Missing commands: @funky
  Missing functions: missing_function

  The first two lines resulting in the Huh? and #-1 are the output
  from the +fun command when run by the user.
& @motd
  COMMAND: @motd[/<switches>] <message>

  This command sets or lists short messages that are displayed to players
  after they successfully log in to the game (or after they fail because
  logins are not allowed). 

  The following switches are available:

     (No switches)   - Sets the message that all players see when they
                       connect.
     /list           - Lists the current messages.
& locate()
  FUNCTION: locate(<looker>,<string>,<where>)

  The locate function is used to look for an object from the perspective of
  <looker> (You must own <looker>).  The database number of the item that
  is found is returned.  The <where> parameter specifies a list of places to
  look, from this list:
    a    - Look for absolute references (#<number>)
    c    - Look for exits carried by <looker> (and by <looker>'s parents).
    e    - Look for exits in <looker>'s location (and the location's parents).
    h    - Look for 'here', which matches <looker>'s location.
    i    - Look in <looker>'s inventory.
    m    - Look for 'me', which matches <looker>.
    n    - Look for <looker>'s neighbors (other objects in the same location).
    p    - Look for player names prefixed by a '*'
    *    - Look for everything in the above list.

{ 'help locate2' for more }
& locate2
LOCATE() (continued)

  You may also specify qualifiers in <where> to help resolve possible
  ambiguities:
    E    - Prefer exits over other types.
    L    - Prefer unlocked exits over locked exits.
    P    - Prefer players over other types.
    R    - Prefer rooms over other types.
    T    - Prefer things over other types.
    V    - Report "Can't find..." and "Which one..." errors to <looker>.
    X    - Select randomly if search finds multiple matches.

  If nothing matches, the value #-1 is returned.  If more than one thing
  of the preferred type matches, but nothing matches exactly, the value #-2
  is returned, except if the X qualifier was specified in which case one is
  chosen at random.  If more than one thing exactly matches, one is chosen
  at random.  If you specify more than one type preference (E, P, R, or T),
  then the last one entered is the one that is obeyed.  The default is for
  no type to be preferred.

{ 'help locate3' for more }
& locate3
LOCATE() (continued)

  Examples:
    > i
    test1(#378)
    test(#376)
    You have 42463 clams.
    > look
    Nullspace(#250R)
    test1(#382)
    > say locate(me,test,i)                > say locate(me,tes,in)
    You say, "#376"                         You say, "#-2"
    > say locate(me,test,n)                > say locate(here,tes,*)
    You say, "#382"                         You say, "#382"
    > say locate(me,test1,in)              > say locate(me,out,e)
    You say, "#378"                         You say, "#252"
    > say locate(me,test1,in)              > say locate(me,here,*)
    You say, "#382"                         You say, "#250"

  Related Topics: num(), PARENT OBJECTS.
& @chown

  COMMAND: @chown <thing>
           @chown <thing> = <player>

  This command allows you to change the ownership of things with the below
  restrictions. Once the ownership has been changed, the object will be set
  HALTED.

  Restrictions:
     1. The thing must be set CHOWN_OK.
     2. The thing can not be a PLAYER.
     3. If the thing is an OBJECT, then you must be carrying the OBJECT
        to @chown it.
     4. If the thing is a ROOM, you must be in the room to @chown it.
     5. If the thing is an EXIT, you must be in the same room as the exit.
     6. If you are trying to @chown an object to someone else, you must be
        a Wizard / God.
& @function

  COMMAND: @function/list
           @function <name> = <object> / <attribute>

  This command is used to manage user defined functions by either listing
  them or defining them to point to a object and attribute. User defined
  @functions will not survive a reboot of the MUSH and must be re-added.

  The functionalty of user defined functions is similar to the use of
  the u() function.

  Example:
     &foo #1 = [add(1,0)]
     > @function bar = #1/foo
     > say [bar(1)]
     You say, "2"
     > say [u(#1/foo,1)]
     You say, "2"

  The use of [bar(1)] is similar to [u(#1/foo,1)] in the above situation.
& @stats

  COMMAND: @stats[/all] [<player>]

  Display the number of objects in the game.  @stats/all gives a
  breakdown by object types.  If <player> is specified, the breakdown
  for the named player is given.  You may only list individual counts
  for yourself.  If invoked with no arguments or switches this command is
  free, but if you specify either /all or <player>, then this command costs
  100 coins to run, because it is computationally expensive.

  Related Topics: stats().
& look

  COMMAND: look[/<switches>] [<object>]

  Displays the description of <object>, or the room you're in if you don't
  specify an object.  Specifying object as <name> or #<dbref> or 'me' or
  'here' is legal.  You can also use look to look at objects held by other
  people, just use 'look <person>'s <object>'.

& @uptime

  COMMAND: @uptime

  Lists how long the MUSH has been up in days, hour, and minutes.
& @sex
  COMMAND:   @sex <object> = <gender>
  ATTRIBUTE: Sex

  Sets the gender for <object>, which is used to determine which pronouns to
  use when replacing %p, %o, %s, and %a parameters in messages that apply to
  <object>.  Genders that start with M or m are considered male, those
  starting with F, f, W, or w are considered female, those starting with
  P or p are considered plural, and anything else is considered neuter.

  Example: @sex me = female
           @sex me = No thank you (Silly, but possible.  Treated as neuter)
& version

  COMMAND: version

  Displays the version of MUSH other tidbits.
& @send
  COMMAND:   @send <message>

  This command is used to send a message over an already open @telnet
  connection. Since only one connection is allowed per object, there is
  no need to specify which connection to use.

  Related Topics: @telnet
& @telnet
  COMMAND:   @telnet <host>:<port>

  This command will open up a connection to a host at the specified port.
  The object issueing the @telnet command must be set SOCKET_PUPPET or
  SOCKET_INPUT. Both flags may only be set by Wizards / God. These two
  flags control only how data is recieved. See below.

  SOCKET_PUPPET
     Input from the socket is handled in a way similar to the user defined
     attribute listens. I.e. "&attribute object = ^* has arrived.". The only
     differences is that the "^" is replaced with a "!" to signify the
     object is listening to @telnet data.

  SOCKET_INPUT
     The input from @telnet is availible via the input() function and
     the function must be called once for each line of input coming from
     the connection. See help input() for more details. This allows a more
     controlled way of dealing with input but can also be more complicated.

  Sending Data
     Data for both types are sent via @send <message>

  Related Topics: @close, @send, flags

& @nohelp
  COMMAND:   @nohelp

  This command lists @commands or functions() without any help.
  This is useful for determing which things need help entries written.
